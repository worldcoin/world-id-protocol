// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import {Test, Vm} from "forge-std/Test.sol";
import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
import {WorldIDBridge} from "../src/core/bridges/WorldIDBridge.sol";
import {WorldIDGateway, StateRelayed} from "../src/core/SequencerGateway.sol";
import {ProofsLib} from "../src/core/lib/ProofsLib.sol";
import {ProvenPubKeyInfo} from "../src/core/interfaces/IWorldIDBridge.sol";
import {BabyJubJub} from "lib/oprf-key-registry/src/BabyJubJub.sol";

/// @dev Test harness for WorldIDBridge — exposes `initialize` since `__WorldIdBridge_init` is internal.
contract TestWorldIDBridge is WorldIDBridge {
    function initialize(
        string memory name_,
        string memory version_,
        address owner_,
        address[] memory gateways_
    ) public {
        __WorldIdBridge_init(name_, version_, owner_, gateways_);
    }
}

/// @title E2ERelayTest
/// @notice End-to-end test for the full World ID relay pipeline:
///   WorldChainBridge (anvil) → MPT proof → SSZ + P2P signature → WorldIDGateway → WorldIDBridge
///
/// @dev Requires FFI. Run:
///   1. Generate fixture:  bash test/scripts/e2e_setup.sh
///   2. Run test:          forge test --match-contract E2ERelay --ffi -vvv
///
///   The setup script deploys WorldChainBridge + mock registries to a local anvil instance,
///   calls propagateState, and writes MPT proofs + commitment data to test/fixtures/e2e_data.json.
///   This test reads that fixture, deploys the destination contracts in-process, builds a real
///   SSZ payload + OP Stack P2P signature, and verifies the full relay flow.
contract E2ERelayTest is Test {
    /// @dev World Chain chain ID used in the OP Stack P2P signing scheme.
    uint256 constant WC_CHAIN_ID = 480;

    /// @dev Expected test values (must match test/scripts/e2e_setup.sh).
    uint256 constant EXPECTED_ROOT = 123456789;
    uint64 constant EXPECTED_ISSUER_ID = 0x5a;
    uint256 constant EXPECTED_ISSUER_X = 1111;
    uint256 constant EXPECTED_ISSUER_Y = 2222;

    /// @dev Fixture data loaded from test/fixtures/e2e_data.json.
    struct Fixture {
        bytes32 stateRoot;
        address wcBridge;
        bytes32 chainHead;
        uint256 latestRoot;
        bytes commitPayload;
        bytes[] accountProof;
        bytes[] storageProof;
    }

    Fixture internal fixture;

    /// @dev Sequencer wallet for signing SSZ payloads.
    Vm.Wallet internal sequencerWallet;

    /// @dev Destination contracts.
    TestWorldIDBridge internal destBridge;
    WorldIDGateway internal gateway;

    // ═══════════════════════════════════════════════════════════
    //                         SETUP
    // ═══════════════════════════════════════════════════════════

    function setUp() public {
        // Load fixture (generated by test/scripts/e2e_setup.sh)
        _loadFixture();

        // Create a deterministic sequencer wallet
        sequencerWallet = vm.createWallet("e2e-sequencer");

        // Deploy destination bridge
        destBridge = _deployWorldIDBridge();

        // Deploy gateway
        gateway = _deployGateway(sequencerWallet.addr, address(destBridge), fixture.wcBridge);

        // Authorize the gateway on the destination bridge
        destBridge.addGateway(address(gateway));
    }

    // ═══════════════════════════════════════════════════════════
    //                       E2E TESTS
    // ═══════════════════════════════════════════════════════════

    /// @notice Full relay: SSZ signature → MPT proof → state applied on destination.
    function test_e2e_fullRelay() public {
        // Build SSZ payload with the WC state root
        bytes memory sszPayload = _buildSSZ(fixture.stateRoot);

        // Sign with the sequencer key
        bytes memory signature = _signSSZ(sszPayload);

        // Convert calldata proofs to memory (SecureMerkleTrie expects memory)
        bytes[] memory accountProof = _toMemory(fixture.accountProof);
        bytes[] memory storageProof = _toMemory(fixture.storageProof);

        // Relay
        vm.expectEmit(true, true, false, false);
        emit StateRelayed(keccak256(sszPayload), fixture.chainHead);

        gateway.relay(sszPayload, signature, accountProof, storageProof, fixture.commitPayload);

        // Verify state arrived on destination
        assertEq(destBridge.LATEST_ROOT(), EXPECTED_ROOT, "Root should match WC registry value");

        // Verify keccak chain head matches
        ProofsLib.Chain memory chain = destBridge.KECCAK_CHAIN();
        assertEq(chain.head, fixture.chainHead, "Chain head should match proven value");
        assertEq(chain.length, 3, "Chain length should be 3 (root + issuer + oprf)");

        // Verify issuer pubkey arrived
        ProvenPubKeyInfo memory info = destBridge.issuerSchemaIdToPubkeyAndProofId(EXPECTED_ISSUER_ID);
        assertEq(info.pubKey.x, EXPECTED_ISSUER_X, "Issuer pubkey X should match");
        assertEq(info.pubKey.y, EXPECTED_ISSUER_Y, "Issuer pubkey Y should match");
    }

    /// @notice Relay with a wrong sequencer key is rejected.
    function test_e2e_wrongSequencer_reverts() public {
        bytes memory sszPayload = _buildSSZ(fixture.stateRoot);

        // Sign with a DIFFERENT key
        Vm.Wallet memory wrongWallet = vm.createWallet("wrong-sequencer");
        bytes32 signingHash = _opStackSigningHash(sszPayload);
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(wrongWallet.privateKey, signingHash);
        bytes memory wrongSig = abi.encodePacked(r, s, v);

        bytes[] memory accountProof = _toMemory(fixture.accountProof);
        bytes[] memory storageProof = _toMemory(fixture.storageProof);

        vm.expectRevert();
        gateway.relay(sszPayload, wrongSig, accountProof, storageProof, fixture.commitPayload);
    }

    /// @notice Relay with tampered state root (wrong MPT proofs) is rejected.
    function test_e2e_tamperedStateRoot_reverts() public {
        // Build SSZ with a WRONG state root
        bytes32 fakeRoot = keccak256("tampered");
        bytes memory sszPayload = _buildSSZ(fakeRoot);
        bytes memory signature = _signSSZ(sszPayload);

        bytes[] memory accountProof = _toMemory(fixture.accountProof);
        bytes[] memory storageProof = _toMemory(fixture.storageProof);

        // MPT proof should fail against the wrong state root
        vm.expectRevert();
        gateway.relay(sszPayload, signature, accountProof, storageProof, fixture.commitPayload);
    }

    /// @notice Relay with tampered commitment payload is rejected (chain head mismatch).
    function test_e2e_tamperedCommitPayload_reverts() public {
        bytes memory sszPayload = _buildSSZ(fixture.stateRoot);
        bytes memory signature = _signSSZ(sszPayload);

        bytes[] memory accountProof = _toMemory(fixture.accountProof);
        bytes[] memory storageProof = _toMemory(fixture.storageProof);

        // Build a different commit payload
        ProofsLib.Commitment[] memory fakeCommits = new ProofsLib.Commitment[](1);
        fakeCommits[0] = ProofsLib.Commitment({
            blockHash: bytes32(uint256(1)),
            data: abi.encodeWithSelector(ProofsLib.UPDATE_ROOT_SELECTOR, uint256(999), uint256(1), bytes32(uint256(1)))
        });
        bytes memory fakePayload = abi.encode(fakeCommits);

        // Chain head won't match the proven value
        vm.expectRevert();
        gateway.relay(sszPayload, signature, accountProof, storageProof, fakePayload);
    }

    /// @notice Double relay is rejected (commitments already applied, chain head moved).
    function test_e2e_doubleRelay_reverts() public {
        bytes memory sszPayload = _buildSSZ(fixture.stateRoot);
        bytes memory signature = _signSSZ(sszPayload);

        bytes[] memory accountProof = _toMemory(fixture.accountProof);
        bytes[] memory storageProof = _toMemory(fixture.storageProof);

        // First relay succeeds
        gateway.relay(sszPayload, signature, accountProof, storageProof, fixture.commitPayload);

        // Second relay fails — chain head has advanced past the proven head
        vm.expectRevert();
        gateway.relay(sszPayload, signature, accountProof, storageProof, fixture.commitPayload);
    }

    // ═══════════════════════════════════════════════════════════
    //                    FIXTURE LOADING
    // ═══════════════════════════════════════════════════════════

    function _loadFixture() internal {
        string memory path = "test/fixtures/e2e_data.json";

        try vm.readFile(path) returns (string memory json) {
            fixture.stateRoot = vm.parseJsonBytes32(json, ".stateRoot");
            fixture.wcBridge = vm.parseJsonAddress(json, ".wcBridge");
            fixture.chainHead = vm.parseJsonBytes32(json, ".chainHead");
            fixture.latestRoot = vm.parseJsonUint(json, ".latestRoot");
            fixture.commitPayload = vm.parseJsonBytes(json, ".commitPayload");

            // Parse proof arrays via vm.parseJson + abi.decode
            fixture.accountProof = abi.decode(vm.parseJson(json, ".accountProof"), (bytes[]));
            fixture.storageProof = abi.decode(vm.parseJson(json, ".storageProof"), (bytes[]));
        } catch {
            revert("E2E fixture not found. Run: bash test/scripts/e2e_setup.sh");
        }
    }

    // ═══════════════════════════════════════════════════════════
    //                   DEPLOYMENT HELPERS
    // ═══════════════════════════════════════════════════════════

    function _deployWorldIDBridge() internal returns (TestWorldIDBridge) {
        TestWorldIDBridge impl = new TestWorldIDBridge();
        address[] memory gateways = new address[](0);
        bytes memory initData =
            abi.encodeCall(TestWorldIDBridge.initialize, ("Destination", "1", address(this), gateways));
        return TestWorldIDBridge(payable(address(new ERC1967Proxy(address(impl), initData))));
    }

    function _deployGateway(address sequencerAddr, address bridge_, address wcBridge_)
        internal
        returns (WorldIDGateway)
    {
        return new WorldIDGateway(address(this), sequencerAddr, bridge_, wcBridge_, WC_CHAIN_ID);
    }

    // ═══════════════════════════════════════════════════════════
    //                     SSZ + SIGNING
    // ═══════════════════════════════════════════════════════════

    /// @dev Builds a mock SSZ-encoded ExecutionPayloadEnvelope with a given stateRoot.
    ///   Layout: ParentBeaconBlockRoot(32) + ParentHash(32) + FeeRecipient(20) + StateRoot(32) + padding
    function _buildSSZ(bytes32 stateRoot) internal pure returns (bytes memory) {
        bytes memory ssz = new bytes(116);
        assembly {
            // stateRoot at offset 84 from start of data
            mstore(add(ssz, add(32, 84)), stateRoot)
        }
        return ssz;
    }

    /// @dev Computes the OP Stack P2P signing hash for a given SSZ payload.
    function _opStackSigningHash(bytes memory sszPayload) internal pure returns (bytes32) {
        bytes32 payloadHash = keccak256(sszPayload);
        return keccak256(abi.encodePacked(bytes32(0), WC_CHAIN_ID, payloadHash));
    }

    /// @dev Signs the SSZ payload with the sequencer wallet using the OP Stack scheme.
    function _signSSZ(bytes memory sszPayload) internal view returns (bytes memory) {
        bytes32 signingHash = _opStackSigningHash(sszPayload);
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(sequencerWallet.privateKey, signingHash);
        return abi.encodePacked(r, s, v);
    }

    /// @dev Deep-copies a bytes[] to ensure memory ownership (calldata → memory).
    function _toMemory(bytes[] memory arr) internal pure returns (bytes[] memory out) {
        out = new bytes[](arr.length);
        for (uint256 i; i < arr.length; ++i) {
            out[i] = arr[i];
        }
    }
}
