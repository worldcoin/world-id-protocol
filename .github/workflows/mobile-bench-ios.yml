name: Mobile Bench (BrowserStack iOS + Android)
run-name: >-
  mobench [${{ inputs.platforms }}] scope=${{ inputs.proof_scope }} modes=${{ inputs.modes }}
  profile=${{ inputs.device_profile }} ref=${{ inputs.mobench_ref }}

on:
  workflow_dispatch:
    inputs:
      mobench_ref:
        description: "Ref (branch/tag/SHA) of worldcoin/mobile-bench-rs to use"
        required: false
        default: "codex/ci-devex"
        type: string
      iterations:
        description: "Benchmark iterations per run"
        required: false
        default: 30
        type: number
      warmup:
        description: "Warmup iterations per run (mobench uses iterations, not milliseconds)"
        required: false
        default: 5
        type: number
      fetch_timeout_secs:
        description: "Timeout waiting for BrowserStack build completion"
        required: false
        default: 1800
        type: number
      platforms:
        description: "Platforms to run"
        required: false
        default: both
        type: choice
        options:
          - both
          - ios
          - android
      proof_scope:
        description: "Proof family scope"
        required: false
        default: both
        type: choice
        options:
          - both
          - pi2
          - pi1
      modes:
        description: "Modes: all | witness | proving | full | comma-separated"
        required: false
        default: all
        type: string
      device_profile:
        description: "Device profile: low-spec | mid-spec | high-spec | auto-low-spec | custom"
        required: false
        default: low-spec
        type: choice
        options:
          - low-spec
          - mid-spec
          - high-spec
          - auto-low-spec
          - custom
      ios_device:
        description: "Optional iOS device override (required when device_profile=custom for iOS)"
        required: false
        default: ""
        type: string
      ios_os_version:
        description: "Optional iOS OS override (required when device_profile=custom for iOS)"
        required: false
        default: ""
        type: string
      android_device:
        description: "Optional Android device override (required when device_profile=custom for Android)"
        required: false
        default: ""
        type: string
      android_os_version:
        description: "Optional Android OS override (required when device_profile=custom for Android)"
        required: false
        default: ""
        type: string
      pr_number:
        description: "Optional PR number for sticky summary comment"
        required: false
        default: ""
        type: string
      requested_by:
        description: "Optional requester login for summary context"
        required: false
        default: ""
        type: string
      request_command:
        description: "Optional /mobench command line used to dispatch this run"
        required: false
        default: ""
        type: string
      also_bench_query:
        description: "Deprecated: query benchmarks are controlled by proof_scope/modes"
        required: false
        default: false
        type: boolean

  workflow_call:
    inputs:
      mobench_ref:
        required: false
        default: "codex/ci-devex"
        type: string
      iterations:
        required: false
        default: 30
        type: number
      warmup:
        required: false
        default: 5
        type: number
      fetch_timeout_secs:
        required: false
        default: 1800
        type: number
      platforms:
        required: false
        default: "both"
        type: string
      proof_scope:
        required: false
        default: "both"
        type: string
      modes:
        required: false
        default: "all"
        type: string
      device_profile:
        required: false
        default: "low-spec"
        type: string
      ios_device:
        required: false
        default: ""
        type: string
      ios_os_version:
        required: false
        default: ""
        type: string
      android_device:
        required: false
        default: ""
        type: string
      android_os_version:
        required: false
        default: ""
        type: string
      pr_number:
        required: false
        default: ""
        type: string
      requested_by:
        required: false
        default: ""
        type: string
      request_command:
        required: false
        default: ""
        type: string
      also_bench_query:
        required: false
        default: false
        type: boolean
    secrets:
      BROWSERSTACK_USERNAME:
        required: true
      BROWSERSTACK_ACCESS_KEY:
        required: true

permissions:
  contents: read

env:
  CARGO_TERM_COLOR: always

jobs:
  ios-browserstack:
    name: iOS BrowserStack benchmark
    if: ${{ inputs.platforms != 'android' }}
    runs-on: macos-15

    env:
      BROWSERSTACK_USERNAME: ${{ secrets.BROWSERSTACK_USERNAME }}
      BROWSERSTACK_ACCESS_KEY: ${{ secrets.BROWSERSTACK_ACCESS_KEY }}
      IPHONEOS_DEPLOYMENT_TARGET: "13.0"
      CFLAGS_aarch64_apple_ios: "-miphoneos-version-min=13.0"
      CFLAGS_aarch64_apple_ios_sim: "-mios-simulator-version-min=13.0"
      CFLAGS_x86_64_apple_ios: "-mios-simulator-version-min=13.0"
      CARGO_TARGET_AARCH64_APPLE_IOS_RUSTFLAGS: "-C link-arg=-miphoneos-version-min=13.0"
      CARGO_TARGET_AARCH64_APPLE_IOS_SIM_RUSTFLAGS: "-C link-arg=-mios-simulator-version-min=13.0"
      CARGO_TARGET_X86_64_APPLE_IOS_RUSTFLAGS: "-C link-arg=-mios-simulator-version-min=13.0"

    steps:
      - name: Checkout world-id-protocol
        uses: actions/checkout@v5
        with:
          path: world-id-protocol

      - name: Checkout mobile-bench-rs
        uses: actions/checkout@v5
        with:
          repository: worldcoin/mobile-bench-rs
          ref: ${{ inputs.mobench_ref }}
          path: mobile-bench-rs

      - name: Hotfix mobench BrowserStack device endpoint
        working-directory: mobile-bench-rs
        run: |
          set -euo pipefail
          python3 - <<'PY'
          from pathlib import Path

          file = Path("crates/mobench/src/browserstack.rs")
          text = file.read_text(encoding="utf-8")
          updated = text.replace(
              'self.get_json("app-automate/espresso/v2/devices")?',
              'self.get_json("app-automate/devices.json")?',
          ).replace(
              'self.get_json("app-automate/xcuitest/v2/devices")?',
              'self.get_json("app-automate/devices.json")?',
          )

          if updated == text:
              raise SystemExit("No endpoint replacements applied in browserstack.rs")

          file.write_text(updated, encoding="utf-8")
          print("Patched BrowserStack device endpoints to app-automate/devices.json")
          PY
          grep -nE "app-automate/.*/devices|app-automate/devices.json" crates/mobench/src/browserstack.rs

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: stable
          targets: aarch64-apple-ios,aarch64-apple-ios-sim,x86_64-apple-ios

      - name: Install XcodeGen
        run: brew install xcodegen

      - name: Install mobench (local build)
        working-directory: world-id-protocol
        run: cargo install --path ../mobile-bench-rs/crates/mobench --locked

      - name: Resolve iOS device (preflight)
        id: resolve_ios
        working-directory: world-id-protocol
        env:
          DEVICE_PROFILE: ${{ inputs.device_profile }}
          IOS_DEVICE_OVERRIDE: ${{ inputs.ios_device }}
          IOS_OS_VERSION_OVERRIDE: ${{ inputs.ios_os_version }}
        run: |
          curl -fsSL -u "${BROWSERSTACK_USERNAME}:${BROWSERSTACK_ACCESS_KEY}" \
            https://api-cloud.browserstack.com/app-automate/devices.json \
            -o /tmp/browserstack-devices-ios.json
          python3 - <<'PY'
          import json
          import os
          import re
          import sys

          with open("/tmp/browserstack-devices-ios.json", "r", encoding="utf-8") as fh:
              devices = json.load(fh)

          profile = os.environ.get("DEVICE_PROFILE", "low-spec").strip().lower()
          custom_name = os.environ.get("IOS_DEVICE_OVERRIDE", "").strip()
          custom_version = os.environ.get("IOS_OS_VERSION_OVERRIDE", "").strip()

          def name_of(item):
              return (item.get("device") or item.get("name") or "").strip()

          def os_of(item):
              return str(item.get("os", "")).strip().lower()

          def version_of(item):
              return str(item.get("os_version", "")).strip()

          def normalize_name(text):
              return re.sub(r"[^a-z0-9]+", " ", text.lower()).strip()

          def normalize_version(text):
              out = str(text).strip().lower().lstrip("v")
              while out.endswith(".0"):
                  out = out[:-2]
              return out

          def version_key(text):
              parts = normalize_version(text).split(".")
              key = []
              for p in parts:
                  key.append(int(p) if p.isdigit() else p)
              return tuple(key)

          def major_version(text):
              first = normalize_version(text).split(".")[0]
              return int(first) if first.isdigit() else 0

          def name_match(actual, expected):
              a = normalize_name(actual)
              e = normalize_name(expected)
              return a == e or a.startswith(f"{e} ")

          def version_match(actual, expected):
              a = normalize_version(actual)
              e = normalize_version(expected)
              return a == e or a.startswith(f"{e}.") or e.startswith(f"{a}.")

          ios_devices = [d for d in devices if os_of(d) == "ios"]
          if not ios_devices:
              print("::error::No iOS devices returned by BrowserStack API.")
              sys.exit(1)

          def find_exact(name, version):
              for d in ios_devices:
                  if name_match(name_of(d), name) and version_match(version_of(d), version):
                      return name_of(d), version_of(d)
              return None

          low_candidates = [
              ("iPhone SE 2020", "16"),
              ("iPhone 13", "16"),
              ("iPhone 14", "16"),
              ("iPhone 12", "17"),
          ]
          mid_candidates = [
              ("iPhone 13", "15"),
              ("iPhone 14", "16"),
          ]
          high_candidates = [
              ("iPhone 16", "18"),
              ("iPhone 17", "26"),
          ]

          selected = None
          if custom_name:
              if not custom_version:
                  print(
                      "::error::ios_os_version must be provided when ios_device override is set."
                  )
                  sys.exit(1)
              selected = find_exact(custom_name, custom_version)
              if not selected:
                  print(
                      f"::error::Requested iOS device not found on BrowserStack: "
                      f"{custom_name} ({custom_version})."
                  )
                  sys.exit(1)
          else:
              if profile == "custom":
                  print(
                      "::error::device_profile=custom requires ios_device and ios_os_version."
                  )
                  sys.exit(1)
              candidates = {
                  "low-spec": low_candidates,
                  "auto-low-spec": low_candidates,
                  "mid-spec": mid_candidates,
                  "high-spec": high_candidates,
              }.get(profile)
              if not candidates:
                  print(f"::error::Unsupported device_profile for iOS: {profile}")
                  sys.exit(1)
              for name, version in candidates:
                  selected = find_exact(name, version)
                  if selected:
                      break

              if not selected and profile == "auto-low-spec":
                  sorted_ios = sorted(
                      ios_devices,
                      key=lambda d: (version_key(version_of(d)), normalize_name(name_of(d))),
                  )
                  supported_ios = [
                      d for d in sorted_ios if major_version(version_of(d)) >= 15
                  ]
                  fallback = (supported_ios or sorted_ios)[0]
                  selected = (name_of(fallback), version_of(fallback))

          if not selected:
              print(
                  "::error::Could not resolve a matching iOS device for the selected profile. "
                  "Update the iOS candidate list in the workflow or provide explicit overrides."
              )
              sys.exit(1)

          out_path = os.environ["GITHUB_OUTPUT"]
          with open(out_path, "a", encoding="utf-8") as out:
              out.write(f"device_name={selected[0]}\n")
              out.write(f"os_version={selected[1]}\n")

          print(f"Selected iOS device: {selected[0]} ({selected[1]})")
          PY

      - name: Write runtime iOS config
        working-directory: world-id-protocol/bench-mobile
        env:
          IOS_DEVICE_NAME: ${{ steps.resolve_ios.outputs.device_name }}
          IOS_OS_VERSION: ${{ steps.resolve_ios.outputs.os_version }}
          ITERATIONS_RAW: ${{ inputs.iterations }}
          WARMUP_RAW: ${{ inputs.warmup }}
        run: |
          python3 - <<'PY'
          import os
          import sys

          device_name = os.environ["IOS_DEVICE_NAME"]
          os_version = os.environ["IOS_OS_VERSION"]

          try:
              iterations = int(os.environ["ITERATIONS_RAW"])
              warmup = int(os.environ["WARMUP_RAW"])
          except ValueError as exc:
              print(f"::error::Invalid numeric input for iOS runtime config: {exc}")
              sys.exit(1)

          with open("device-matrix.ios.runtime.yaml", "w", encoding="utf-8") as fh:
              device_identifier = f"{device_name}-{os_version}"
              fh.write("devices:\n")
              fh.write(f'  - name: "{device_identifier}"\n')
              fh.write('    os: "ios"\n')
              fh.write(f'    os_version: "{os_version}"\n')
              fh.write('    tags: ["runtime", "ios"]\n')

          with open("bench-config.ios.runtime.toml", "w", encoding="utf-8") as fh:
              fh.write('target = "ios"\n')
              fh.write('function = "bench_mobile::bench_nullifier_proving_only"\n')
              fh.write(f"iterations = {iterations}\n")
              fh.write(f"warmup = {warmup}\n")
              fh.write('device_matrix = "device-matrix.ios.runtime.yaml"\n')
              fh.write('device_tags = ["runtime"]\n\n')
              fh.write("[browserstack]\n")
              fh.write('app_automate_username = "${BROWSERSTACK_USERNAME}"\n')
              fh.write('app_automate_access_key = "${BROWSERSTACK_ACCESS_KEY}"\n')
              fh.write('project = "mobile-bench-rs"\n\n')
              fh.write("[ios_xcuitest]\n")
              fh.write('app = "target/mobench/ios/BenchRunner.ipa"\n')
              fh.write('test_suite = "target/mobench/ios/BenchRunnerUITests.zip"\n')
          PY

      - name: Build iOS BrowserStack artifacts
        working-directory: world-id-protocol
        run: |
          set -euo pipefail
          cargo-mobench build --target ios
          cargo-mobench package-ipa --method adhoc
          cargo-mobench package-xcuitest
          test -f target/mobench/ios/BenchRunner.ipa
          test -f target/mobench/ios/BenchRunnerUITests.zip

      - name: Run iOS benchmark matrix
        working-directory: world-id-protocol/bench-mobile
        env:
          PROOF_SCOPE: ${{ inputs.proof_scope }}
          BENCH_MODES: ${{ inputs.modes }}
          ITERATIONS_RAW: ${{ inputs.iterations }}
          WARMUP_RAW: ${{ inputs.warmup }}
          FETCH_TIMEOUT_SECS_RAW: ${{ inputs.fetch_timeout_secs }}
        run: |
          set -euo pipefail

          validate_uint() {
            local name="$1"
            local value="$2"
            if [[ -z "$value" || ! "$value" =~ ^[0-9]+$ ]]; then
              echo "::error::Invalid ${name}: '${value}' (expected a non-negative integer)"
              exit 1
            fi
          }

          validate_uint "iterations" "$ITERATIONS_RAW"
          validate_uint "warmup" "$WARMUP_RAW"
          validate_uint "fetch_timeout_secs" "$FETCH_TIMEOUT_SECS_RAW"

          ITERATIONS="$ITERATIONS_RAW"
          WARMUP="$WARMUP_RAW"
          FETCH_TIMEOUT_SECS="$FETCH_TIMEOUT_SECS_RAW"

          if (( ITERATIONS < 1 )); then
            echo "::error::iterations must be >= 1 (got ${ITERATIONS})"
            exit 1
          fi
          if (( FETCH_TIMEOUT_SECS < 1 )); then
            echo "::error::fetch_timeout_secs must be >= 1 (got ${FETCH_TIMEOUT_SECS})"
            exit 1
          fi

          scope="$(printf '%s' "${PROOF_SCOPE}" | tr '[:upper:]' '[:lower:]')"
          modes="$(printf '%s' "${BENCH_MODES}" | tr '[:upper:]' '[:lower:]')"
          modes="${modes//[[:space:]]/}"
          if [[ -z "$modes" ]]; then
            modes="all"
          fi

          case "$scope" in
            both|pi1|pi2) ;;
            *)
              echo "::error::Invalid proof_scope: '$scope' (expected: both|pi1|pi2)"
              exit 1
              ;;
          esac

          mode_enabled() {
            local mode="$1"
            [[ "$modes" == "all" ]] && return 0
            [[ ",$modes," == *",$mode,"* ]]
          }

          scope_enabled() {
            local bench_scope="$1"
            [[ "$scope" == "both" || "$scope" == "$bench_scope" ]]
          }

          mkdir -p target/mobench/ci/ios

          benches=(
            "pi2 witness bench_mobile::bench_nullifier_witness_generation_only nullifier-witness"
            "pi2 proving bench_mobile::bench_nullifier_proving_only nullifier-proving"
            "pi2 full bench_mobile::bench_nullifier_proof_generation nullifier-full"
            "pi1 witness bench_mobile::bench_query_witness_generation_only query-witness"
            "pi1 proving bench_mobile::bench_query_proving_only query-proving"
            "pi1 full bench_mobile::bench_query_proof_generation query-full"
          )

          selected=0
          for bench in "${benches[@]}"; do
            read -r bench_scope bench_mode function output <<<"$bench"
            if ! scope_enabled "$bench_scope"; then
              continue
            fi
            if ! mode_enabled "$bench_mode"; then
              continue
            fi
            selected=$((selected + 1))
            config_path="bench-config.ios.runtime.${output}.toml"
            awk -v fn="$function" '
              BEGIN { replaced = 0 }
              /^function[[:space:]]*=/ && !replaced {
                print "function = \"" fn "\""
                replaced = 1
                next
              }
              { print }
              END {
                if (!replaced) {
                  print "function = \"" fn "\""
                }
              }
            ' bench-config.ios.runtime.toml > "${config_path}"
            cargo-mobench run \
              --target ios \
              --function "${function}" \
              --iterations "${ITERATIONS}" \
              --warmup "${WARMUP}" \
              --config "${config_path}" \
              --release \
              --fetch \
              --fetch-timeout-secs "${FETCH_TIMEOUT_SECS}" \
              --summary-csv \
              --output "target/mobench/ci/ios/${output}.json"
          done

          if [[ "$selected" -eq 0 ]]; then
            echo "::error::No iOS benchmarks selected by proof_scope='${scope}' and modes='${modes}'."
            exit 1
          fi

      - name: Upload iOS results
        uses: actions/upload-artifact@v4
        with:
          name: mobench-ios-results
          path: |
            world-id-protocol/target/mobench/ci/ios/*.json
            world-id-protocol/target/mobench/ci/ios/*.csv
            world-id-protocol/target/browserstack/**
            world-id-protocol/bench-mobile/bench-config.ios.runtime*.toml

  android-browserstack:
    name: Android BrowserStack benchmark
    if: ${{ inputs.platforms != 'ios' }}
    runs-on: macos-14

    env:
      BROWSERSTACK_USERNAME: ${{ secrets.BROWSERSTACK_USERNAME }}
      BROWSERSTACK_ACCESS_KEY: ${{ secrets.BROWSERSTACK_ACCESS_KEY }}

    steps:
      - name: Checkout world-id-protocol
        uses: actions/checkout@v5
        with:
          path: world-id-protocol

      - name: Checkout mobile-bench-rs
        uses: actions/checkout@v5
        with:
          repository: worldcoin/mobile-bench-rs
          ref: ${{ inputs.mobench_ref }}
          path: mobile-bench-rs

      - name: Hotfix mobench BrowserStack device endpoint
        working-directory: mobile-bench-rs
        run: |
          set -euo pipefail
          python3 - <<'PY'
          from pathlib import Path

          file = Path("crates/mobench/src/browserstack.rs")
          text = file.read_text(encoding="utf-8")
          updated = text.replace(
              'self.get_json("app-automate/espresso/v2/devices")?',
              'self.get_json("app-automate/devices.json")?',
          ).replace(
              'self.get_json("app-automate/xcuitest/v2/devices")?',
              'self.get_json("app-automate/devices.json")?',
          )

          if updated == text:
              raise SystemExit("No endpoint replacements applied in browserstack.rs")

          file.write_text(updated, encoding="utf-8")
          print("Patched BrowserStack device endpoints to app-automate/devices.json")
          PY
          grep -nE "app-automate/.*/devices|app-automate/devices.json" crates/mobench/src/browserstack.rs

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: stable
          targets: aarch64-linux-android,armv7-linux-androideabi,x86_64-linux-android

      - name: Setup Android SDK
        uses: android-actions/setup-android@v3

      - name: Install cargo-ndk
        working-directory: world-id-protocol
        run: cargo install cargo-ndk --locked

      - name: Install mobench (local build)
        working-directory: world-id-protocol
        run: cargo install --path ../mobile-bench-rs/crates/mobench --locked

      - name: Resolve Android device (preflight)
        id: resolve_android
        working-directory: world-id-protocol
        env:
          DEVICE_PROFILE: ${{ inputs.device_profile }}
          ANDROID_DEVICE_OVERRIDE: ${{ inputs.android_device }}
          ANDROID_OS_VERSION_OVERRIDE: ${{ inputs.android_os_version }}
        run: |
          curl -fsSL -u "${BROWSERSTACK_USERNAME}:${BROWSERSTACK_ACCESS_KEY}" \
            https://api-cloud.browserstack.com/app-automate/devices.json \
            -o /tmp/browserstack-devices-android.json
          python3 - <<'PY'
          import json
          import os
          import re
          import sys

          with open("/tmp/browserstack-devices-android.json", "r", encoding="utf-8") as fh:
              devices = json.load(fh)

          profile = os.environ.get("DEVICE_PROFILE", "low-spec").strip().lower()
          custom_name = os.environ.get("ANDROID_DEVICE_OVERRIDE", "").strip()
          custom_version = os.environ.get("ANDROID_OS_VERSION_OVERRIDE", "").strip()

          def name_of(item):
              return (item.get("device") or item.get("name") or "").strip()

          def os_of(item):
              return str(item.get("os", "")).strip().lower()

          def version_of(item):
              return str(item.get("os_version", "")).strip()

          def normalize_name(text):
              return re.sub(r"[^a-z0-9]+", " ", text.lower()).strip()

          def normalize_version(text):
              out = str(text).strip().lower().lstrip("v")
              while out.endswith(".0"):
                  out = out[:-2]
              return out

          def version_key(text):
              parts = normalize_version(text).split(".")
              key = []
              for p in parts:
                  key.append(int(p) if p.isdigit() else p)
              return tuple(key)

          def name_match(actual, expected):
              a = normalize_name(actual)
              e = normalize_name(expected)
              return a == e or a.startswith(f"{e} ")

          def version_match(actual, expected):
              a = normalize_version(actual)
              e = normalize_version(expected)
              return a == e or a.startswith(f"{e}.") or e.startswith(f"{a}.")

          android_devices = [d for d in devices if os_of(d) == "android"]
          if not android_devices:
              print("::error::No Android devices returned by BrowserStack API.")
              sys.exit(1)

          def find_exact(name, version):
              for d in android_devices:
                  if name_match(name_of(d), name) and version_match(version_of(d), version):
                      return name_of(d), version_of(d)
              return None

          low_candidates = [
              ("Motorola Moto G9 Play", "10"),
              ("Samsung Galaxy S20", "10"),
              ("Samsung Galaxy S20 Ultra", "10"),
              ("Xiaomi Redmi Note 9", "10"),
              ("Google Pixel 5", "11"),
          ]
          mid_candidates = [
              ("Google Pixel 6", "12"),
              ("Samsung Galaxy S21", "12"),
          ]
          high_candidates = [
              ("Samsung Galaxy S24", "14"),
              ("Google Pixel 10", "16"),
          ]

          selected = None
          if custom_name:
              if not custom_version:
                  print(
                      "::error::android_os_version must be provided when android_device override is set."
                  )
                  sys.exit(1)
              selected = find_exact(custom_name, custom_version)
              if not selected:
                  print(
                      f"::error::Requested Android device not found on BrowserStack: "
                      f"{custom_name} ({custom_version})."
                  )
                  sys.exit(1)
          else:
              if profile == "custom":
                  print(
                      "::error::device_profile=custom requires android_device and android_os_version."
                  )
                  sys.exit(1)
              candidates = {
                  "low-spec": low_candidates,
                  "auto-low-spec": low_candidates,
                  "mid-spec": mid_candidates,
                  "high-spec": high_candidates,
              }.get(profile)
              if not candidates:
                  print(f"::error::Unsupported device_profile for Android: {profile}")
                  sys.exit(1)
              for name, version in candidates:
                  selected = find_exact(name, version)
                  if selected:
                      break

              if not selected and profile == "auto-low-spec":
                  sorted_android = sorted(
                      android_devices,
                      key=lambda d: (version_key(version_of(d)), normalize_name(name_of(d))),
                  )
                  fallback = sorted_android[0]
                  selected = (name_of(fallback), version_of(fallback))

          if not selected:
              print(
                  "::error::Could not resolve a matching Android device for the selected profile. "
                  "Update the Android candidate list in the workflow or provide explicit overrides."
              )
              sys.exit(1)

          out_path = os.environ["GITHUB_OUTPUT"]
          with open(out_path, "a", encoding="utf-8") as out:
              out.write(f"device_name={selected[0]}\n")
              out.write(f"os_version={selected[1]}\n")

          print(f"Selected Android device: {selected[0]} ({selected[1]})")
          PY

      - name: Write runtime Android config
        working-directory: world-id-protocol/bench-mobile
        env:
          ANDROID_DEVICE_NAME: ${{ steps.resolve_android.outputs.device_name }}
          ANDROID_OS_VERSION: ${{ steps.resolve_android.outputs.os_version }}
          ITERATIONS_RAW: ${{ inputs.iterations }}
          WARMUP_RAW: ${{ inputs.warmup }}
        run: |
          python3 - <<'PY'
          import os
          import sys

          device_name = os.environ["ANDROID_DEVICE_NAME"]
          os_version = os.environ["ANDROID_OS_VERSION"]

          try:
              iterations = int(os.environ["ITERATIONS_RAW"])
              warmup = int(os.environ["WARMUP_RAW"])
          except ValueError as exc:
              print(f"::error::Invalid numeric input for Android runtime config: {exc}")
              sys.exit(1)

          with open("device-matrix.android.runtime.yaml", "w", encoding="utf-8") as fh:
              device_identifier = f"{device_name}-{os_version}"
              fh.write("devices:\n")
              fh.write(f'  - name: "{device_identifier}"\n')
              fh.write('    os: "android"\n')
              fh.write(f'    os_version: "{os_version}"\n')
              fh.write('    tags: ["runtime", "android"]\n')

          with open("bench-config.android.runtime.toml", "w", encoding="utf-8") as fh:
              fh.write('target = "android"\n')
              fh.write('function = "bench_mobile::bench_nullifier_proving_only"\n')
              fh.write(f"iterations = {iterations}\n")
              fh.write(f"warmup = {warmup}\n")
              fh.write('device_matrix = "device-matrix.android.runtime.yaml"\n')
              fh.write('device_tags = ["runtime"]\n\n')
              fh.write("[browserstack]\n")
              fh.write('app_automate_username = "${BROWSERSTACK_USERNAME}"\n')
              fh.write('app_automate_access_key = "${BROWSERSTACK_ACCESS_KEY}"\n')
              fh.write('project = "mobile-bench-rs"\n')
          PY

      - name: Run Android benchmark matrix
        working-directory: world-id-protocol/bench-mobile
        env:
          PROOF_SCOPE: ${{ inputs.proof_scope }}
          BENCH_MODES: ${{ inputs.modes }}
          ITERATIONS_RAW: ${{ inputs.iterations }}
          WARMUP_RAW: ${{ inputs.warmup }}
          FETCH_TIMEOUT_SECS_RAW: ${{ inputs.fetch_timeout_secs }}
          CARGO_NDK_PLATFORM: "28"
          ANDROID_PLATFORM: "28"
        run: |
          set -euo pipefail

          validate_uint() {
            local name="$1"
            local value="$2"
            if [[ -z "$value" || ! "$value" =~ ^[0-9]+$ ]]; then
              echo "::error::Invalid ${name}: '${value}' (expected a non-negative integer)"
              exit 1
            fi
          }

          validate_uint "iterations" "$ITERATIONS_RAW"
          validate_uint "warmup" "$WARMUP_RAW"
          validate_uint "fetch_timeout_secs" "$FETCH_TIMEOUT_SECS_RAW"

          ITERATIONS="$ITERATIONS_RAW"
          WARMUP="$WARMUP_RAW"
          FETCH_TIMEOUT_SECS="$FETCH_TIMEOUT_SECS_RAW"

          if (( ITERATIONS < 1 )); then
            echo "::error::iterations must be >= 1 (got ${ITERATIONS})"
            exit 1
          fi
          if (( FETCH_TIMEOUT_SECS < 1 )); then
            echo "::error::fetch_timeout_secs must be >= 1 (got ${FETCH_TIMEOUT_SECS})"
            exit 1
          fi

          scope="$(printf '%s' "${PROOF_SCOPE}" | tr '[:upper:]' '[:lower:]')"
          modes="$(printf '%s' "${BENCH_MODES}" | tr '[:upper:]' '[:lower:]')"
          modes="${modes//[[:space:]]/}"
          if [[ -z "$modes" ]]; then
            modes="all"
          fi

          case "$scope" in
            both|pi1|pi2) ;;
            *)
              echo "::error::Invalid proof_scope: '$scope' (expected: both|pi1|pi2)"
              exit 1
              ;;
          esac

          mode_enabled() {
            local mode="$1"
            [[ "$modes" == "all" ]] && return 0
            [[ ",$modes," == *",$mode,"* ]]
          }

          scope_enabled() {
            local bench_scope="$1"
            [[ "$scope" == "both" || "$scope" == "$bench_scope" ]]
          }

          mkdir -p target/mobench/ci/android

          benches=(
            "pi2 witness bench_mobile::bench_nullifier_witness_generation_only nullifier-witness"
            "pi2 proving bench_mobile::bench_nullifier_proving_only nullifier-proving"
            "pi2 full bench_mobile::bench_nullifier_proof_generation nullifier-full"
            "pi1 witness bench_mobile::bench_query_witness_generation_only query-witness"
            "pi1 proving bench_mobile::bench_query_proving_only query-proving"
            "pi1 full bench_mobile::bench_query_proof_generation query-full"
          )

          selected=0
          for bench in "${benches[@]}"; do
            read -r bench_scope bench_mode function output <<<"$bench"
            if ! scope_enabled "$bench_scope"; then
              continue
            fi
            if ! mode_enabled "$bench_mode"; then
              continue
            fi
            selected=$((selected + 1))
            config_path="bench-config.android.runtime.${output}.toml"
            awk -v fn="$function" '
              BEGIN { replaced = 0 }
              /^function[[:space:]]*=/ && !replaced {
                print "function = \"" fn "\""
                replaced = 1
                next
              }
              { print }
              END {
                if (!replaced) {
                  print "function = \"" fn "\""
                }
              }
            ' bench-config.android.runtime.toml > "${config_path}"
            cargo-mobench run \
              --target android \
              --function "${function}" \
              --iterations "${ITERATIONS}" \
              --warmup "${WARMUP}" \
              --config "${config_path}" \
              --release \
              --fetch \
              --fetch-timeout-secs "${FETCH_TIMEOUT_SECS}" \
              --summary-csv \
              --output "target/mobench/ci/android/${output}.json"
          done

          if [[ "$selected" -eq 0 ]]; then
            echo "::error::No Android benchmarks selected by proof_scope='${scope}' and modes='${modes}'."
            exit 1
          fi

      - name: Upload Android results
        uses: actions/upload-artifact@v4
        with:
          name: mobench-android-results
          path: |
            world-id-protocol/target/mobench/ci/android/*.json
            world-id-protocol/target/mobench/ci/android/*.csv
            world-id-protocol/target/browserstack/**
            world-id-protocol/bench-mobile/bench-config.android.runtime*.toml

  summarize:
    name: Summarize mobench results
    needs:
      - ios-browserstack
      - android-browserstack
    if: ${{ always() }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
      pull-requests: read

    steps:
      - name: Checkout world-id-protocol
        uses: actions/checkout@v5
        with:
          path: world-id-protocol

      - name: Download iOS artifact
        uses: actions/download-artifact@v4
        with:
          name: mobench-ios-results
          path: artifacts/ios
          if-no-artifact-found: ignore

      - name: Download Android artifact
        uses: actions/download-artifact@v4
        with:
          name: mobench-android-results
          path: artifacts/android
          if-no-artifact-found: ignore

      - name: Generate interpreted markdown summary
        env:
          IOS_RESULT: ${{ needs.ios-browserstack.result }}
          ANDROID_RESULT: ${{ needs.android-browserstack.result }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        run: |
          set -euo pipefail
          python3 world-id-protocol/bench-mobile/scripts/summarize_mobench_ci.py \
            --ios-dir artifacts/ios \
            --android-dir artifacts/android \
            --ios-result "${IOS_RESULT}" \
            --android-result "${ANDROID_RESULT}" \
            --platforms "${{ inputs.platforms }}" \
            --proof-scope "${{ inputs.proof_scope }}" \
            --modes "${{ inputs.modes }}" \
            --device-profile "${{ inputs.device_profile }}" \
            --mobench-ref "${{ inputs.mobench_ref }}" \
            --run-url "${RUN_URL}" \
            --pr-number "${{ inputs.pr_number }}" \
            --requested-by "${{ inputs.requested_by }}" \
            --request-command "${{ inputs.request_command }}" \
            --output /tmp/mobench-summary.md

      - name: Publish summary to workflow UI
        run: |
          cat /tmp/mobench-summary.md >> "${GITHUB_STEP_SUMMARY}"

      - name: Upsert PR summary comment
        if: ${{ inputs.pr_number != '' }}
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ inputs.pr_number }}
          SUMMARY_FILE: /tmp/mobench-summary.md
        with:
          script: |
            const fs = require("fs");
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issueNumber = Number(process.env.PR_NUMBER || "");
            if (!Number.isInteger(issueNumber) || issueNumber <= 0) {
              core.warning(`Skipping PR summary comment: invalid PR number '${process.env.PR_NUMBER}'`);
              return;
            }

            const marker = "<!-- mobench-summary -->";
            const summary = fs.readFileSync(process.env.SUMMARY_FILE, "utf8");
            const body = `${marker}\n${summary}`;

            const comments = await github.paginate(github.rest.issues.listComments, {
              owner,
              repo,
              issue_number: issueNumber,
              per_page: 100,
            });

            const existing = comments.find((c) => c.body && c.body.includes(marker));
            if (existing) {
              await github.rest.issues.updateComment({
                owner,
                repo,
                comment_id: existing.id,
                body,
              });
            } else {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: issueNumber,
                body,
              });
            }
